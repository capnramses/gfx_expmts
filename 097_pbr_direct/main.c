#include "gfx.h"
#include "apg_maths.h"
#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>

// see http://www.songho.ca/opengl/gl_sphere.html -- also has code for verts, normals
static void _gen_uv_sphere( int stackCount, int sectorCount, float radius, vec3* vertices_ptr, uint32_t* n_verts_ptr, uint32_t* indices_ptr, uint32_t* n_indices_ptr ) {
  uint32_t n_verts = 0;
  for ( int i = 0; i <= stackCount; ++i ) {
    float stackAngle = APG_M_PI / 2.0f - (float)( i * APG_M_PI / (float)stackCount ); // starting from pi/2 to -pi/2
    float xy         = radius * cosf( stackAngle );                                   // r * cos(u)
    float z          = radius * sinf( stackAngle );                                   // r * sin(u)
    // add (sectorCount+1) vertices per stack
    // the first and last vertices have same position and normal, but different tex coords
    for ( int j = 0; j <= sectorCount; ++j ) {
      float sectorStep        = 2.0f * APG_M_PI / (float)sectorCount;
      vertices_ptr[n_verts++] = ( vec3 ){ .x = xy * cosf( j * sectorStep ), .y = xy * sinf( j * sectorStep ), .z = z };
    }
  }
  *n_verts_ptr = n_verts;

  // generate CCW index list of sphere triangles
  uint32_t n_indices = 0;
  for ( int i = 0; i < stackCount; ++i ) {
    int k1 = i * ( sectorCount + 1 ); // beginning of current stack
    int k2 = k1 + sectorCount + 1;    // beginning of next stack

    for ( int j = 0; j < sectorCount; ++j, ++k1, ++k2 ) {
      // 2 triangles per sector excluding first and last stacks
      // k1 => k2 => k1+1
      if ( i != 0 ) {
        indices_ptr[n_indices++] = k1;
        indices_ptr[n_indices++] = k2;
        indices_ptr[n_indices++] = k1 + 1;
      }

      // k1+1 => k2 => k2+1
      if ( i != ( stackCount - 1 ) ) {
        indices_ptr[n_indices++] = k1 + 1;
        indices_ptr[n_indices++] = k2;
        indices_ptr[n_indices++] = k2 + 1;
      }
    }
  }
  *n_indices_ptr = n_indices;
}

static void _dump_obj( const vec3* verts_ptr, const uint32_t* indices_ptr, uint32_t n_verts, uint32_t n_indices ) {
  FILE* f_ptr = fopen( "out.obj", "w" );
  assert( f_ptr );

  fprintf( f_ptr, "#Wavefront .obj generated by _dump_obj() util by Anton Gerdelan\n" );
  for ( uint32_t v = 0; v < n_verts; v++ ) { fprintf( f_ptr, "v %f %f %f\n", verts_ptr[v].x, verts_ptr[v].y, verts_ptr[v].z ); }
  for ( uint32_t i = 0; i < n_indices; i += 3 ) { fprintf( f_ptr, "f %u %u %u\n", indices_ptr[i + 0] + 1, indices_ptr[i + 1] + 1, indices_ptr[i + 2] + 1 ); }
  fclose( f_ptr );
}

int main() {
  // load a sphere mesh
  vec3 verts[4096];
  uint32_t indices[4096];
  int n_verts = 0, n_indices = 0;
  _gen_uv_sphere( 16, 16, 1.0f, verts, &n_verts, indices, &n_indices );
  printf( "UV sphere generated: %u verts, %u indices\n", n_verts, n_indices );
  _dump_obj( verts, indices, n_verts, n_indices );

  // load a shader with a UBO for PBR stuff

  // loop over nxm spheres with varying inputs

  gfx_start( "PBR spheres direct lighting demo", 1024, 1024, false );

  gfx_mesh_t sphere_mesh =
    gfx_create_mesh_from_mem( &verts[0].x, 3, NULL, 0, NULL, 0, NULL, 0, indices, sizeof( uint32_t ) * n_indices, GFX_INDICES_TYPE_UINT32, n_verts, false );
  gfx_shader_t sphere_shader = gfx_create_shader_program_from_files( "sphere.vert", "sphere.frag" );

  gfx_wireframe_mode();
  gfx_backface_culling( false );

  while ( !gfx_should_window_close() ) {
    int fb_w = 0, fb_h = 0;
    gfx_framebuffer_dims( &fb_w, &fb_h );
    float aspect = (float)fb_w / (float)fb_h;
    mat4 M       = rot_y_deg_mat4( gfx_get_time_s() * 10.0 );
    mat4 V       = look_at( ( vec3 ){ 0, 0, 2.0f }, ( vec3 ){ 0, 0, 0 }, ( vec3 ){ 0, 1, 0 } );
    mat4 P       = perspective( 67, aspect, 0.1, 1000.0 );

    gfx_viewport( 0, 0, fb_w, fb_h );
    gfx_clear_colour_and_depth_buffers( 0.2, 0.2, 0.2, 1.0 );

    gfx_draw_mesh( sphere_mesh, GFX_PT_TRIANGLES, sphere_shader, P.m, V.m, M.m, NULL, 0 );

    gfx_swap_buffer();
    gfx_poll_events();
  }

  gfx_stop();

  //

  return 0;
}
