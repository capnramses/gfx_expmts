#include "gfx.h"
#include "apg_maths.h"
#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>

// see http://www.songho.ca/opengl/gl_sphere.html -- also has code for verts, normals
static void _gen_uv_sphere( int stackCount, int sectorCount, float radius, vec3* vertices_ptr, uint32_t* n_verts_ptr, uint32_t* indices_ptr, uint32_t* n_indices_ptr ) {
  uint32_t n_verts = 0;
  for ( int i = 0; i <= stackCount; ++i ) {
    float stackAngle = APG_M_PI / 2.0f - (float)( i * APG_M_PI / (float)stackCount ); // starting from pi/2 to -pi/2
    float xy         = radius * cosf( stackAngle );                                   // r * cos(u)
    float z          = radius * sinf( stackAngle );                                   // r * sin(u)
    // add (sectorCount+1) vertices per stack
    // the first and last vertices have same position and normal, but different tex coords
    for ( int j = 0; j <= sectorCount; ++j ) {
      float sectorStep        = 2.0f * APG_M_PI / (float)sectorCount;
      vertices_ptr[n_verts++] = ( vec3 ){ .x = xy * cosf( j * sectorStep ), .y = xy * sinf( j * sectorStep ), .z = z };
    }
  }
  *n_verts_ptr = n_verts;

  // generate CCW index list of sphere triangles
  uint32_t n_indices = 0;
  for ( int i = 0; i < stackCount; ++i ) {
    int k1 = i * ( sectorCount + 1 ); // beginning of current stack
    int k2 = k1 + sectorCount + 1;    // beginning of next stack

    for ( int j = 0; j < sectorCount; ++j, ++k1, ++k2 ) {
      // 2 triangles per sector excluding first and last stacks
      // k1 => k2 => k1+1
      if ( i != 0 ) {
        indices_ptr[n_indices++] = k1;
        indices_ptr[n_indices++] = k2;
        indices_ptr[n_indices++] = k1 + 1;
      }

      // k1+1 => k2 => k2+1
      if ( i != ( stackCount - 1 ) ) {
        indices_ptr[n_indices++] = k1 + 1;
        indices_ptr[n_indices++] = k2;
        indices_ptr[n_indices++] = k2 + 1;
      }
    }
  }
  *n_indices_ptr = n_indices;
}

static void _dump_obj( const vec3* verts_ptr, const uint32_t* indices_ptr, uint32_t n_verts, uint32_t n_indices ) {
  FILE* f_ptr = fopen( "out.obj", "w" );
  assert( f_ptr );

  fprintf( f_ptr, "#Wavefront .obj generated by _dump_obj() util by Anton Gerdelan\n" );
  for ( uint32_t v = 0; v < n_verts; v++ ) { fprintf( f_ptr, "v %f %f %f\n", verts_ptr[v].x, verts_ptr[v].y, verts_ptr[v].z ); }
  for ( uint32_t i = 0; i < n_indices; i += 3 ) { fprintf( f_ptr, "f %u %u %u\n", indices_ptr[i + 0] + 1, indices_ptr[i + 1] + 1, indices_ptr[i + 2] + 1 ); }
  fclose( f_ptr );
}

int main() {
  // load a sphere mesh
  vec3 verts[4096];
  uint32_t indices[4096];
  int n_verts = 0, n_indices = 0;
  _gen_uv_sphere( 16, 16, 1.0f, verts, &n_verts, indices, &n_indices );
  printf( "UV sphere generated: %u verts, %u indices\n", n_verts, n_indices );
  _dump_obj( verts, indices, n_verts, n_indices );

  // load a shader with a UBO for PBR stuff

  // loop over nxm spheres with varying inputs

  gfx_start( "PBR spheres direct lighting demo", 1024, 1024, false );

  gfx_mesh_t sphere_mesh =
    gfx_create_mesh_from_mem( &verts[0].x, 3, NULL, 0, NULL, 0, NULL, 0, indices, sizeof( uint32_t ) * n_indices, GFX_INDICES_TYPE_UINT32, n_verts, false );
  gfx_shader_t sphere_shader = gfx_create_shader_program_from_files( "sphere.vert", "sphere.frag" );

  vec3 light_pos_wor_initial = ( vec3 ){ 0, 5, 15 };

  // gfx_wireframe_mode();
  // gfx_backface_culling( false );

  while ( !gfx_should_window_close() ) {
    int fb_w = 0, fb_h = 0;
    gfx_framebuffer_dims( &fb_w, &fb_h );
    float aspect     = (float)fb_w / (float)fb_h;
    vec3 cam_pos_wor = ( vec3 ){ 0, 0, 15.0f };
    mat4 V           = look_at( cam_pos_wor, ( vec3 ){ 0, 0, 0 }, ( vec3 ){ 0, 1, 0 } );
    mat4 P           = perspective( 67, aspect, 0.1, 1000.0 );

    gfx_viewport( 0, 0, fb_w, fb_h );
    gfx_clear_colour_and_depth_buffers( 0.2, 0.2, 0.2, 1.0 );

    // rotate light around z axis
    mat4 R_light = rot_z_deg_mat4( gfx_get_time_s() * 100.0 );

    vec4 light_pos_curr_wor_xyzw = mult_mat4_vec4( R_light, v4_v3f( light_pos_wor_initial, 1.0 ) );

    int n_across = 5;
    int n_down   = 5;
    for ( int yi = 0; yi < n_down; yi++ ) {
      float y = (float)yi * 3.0f - ( ( n_down - 1 ) * 3 * 0.5f );
      for ( int xi = 0; xi < n_across; xi++ ) {
        // u_roughness_factor
        float x = (float)xi * 3.0f - ( ( n_across - 1 ) * 3 * 0.5f );
        mat4 T  = translate_mat4( ( vec3 ){ x, y, 0 } );
        mat4 R  = rot_y_deg_mat4( gfx_get_time_s() * 10.0 );
        mat4 M  = mult_mat4_mat4( T, R );

        float roughness = (float)xi / (float)( n_across - 1 );
        float metallic  = (float)yi / (float)( n_down - 1 );
        // printf( "roughness = %f, metallic = %f\n", roughness, metallic );
        gfx_uniform1f( sphere_shader, sphere_shader.u_roughness_factor, roughness );
        gfx_uniform1f( sphere_shader, sphere_shader.u_metallic_factor, metallic );
        gfx_uniform3f( sphere_shader, sphere_shader.u_light_pos_wor, light_pos_curr_wor_xyzw.x, light_pos_curr_wor_xyzw.y, light_pos_curr_wor_xyzw.z );
        gfx_uniform3f( sphere_shader, sphere_shader.u_cam_pos_wor, cam_pos_wor.x, cam_pos_wor.y, cam_pos_wor.z );

        gfx_draw_mesh( sphere_mesh, GFX_PT_TRIANGLES, sphere_shader, P.m, V.m, M.m, NULL, 0 );
      }
    }

    gfx_swap_buffer();
    gfx_poll_events();
  }

  gfx_stop();

  //

  return 0;
}
